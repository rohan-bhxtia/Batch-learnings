<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two-Hand Galaxy Control</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        
        #input-video {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 280px;
            height: 210px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.1);
            transform: rotateY(180deg);
            z-index: 5;
            background: #111;
        }

        #overlay {
            position: absolute;
            top: 30px;
            left: 30px;
            color: white;
            z-index: 10;
            pointer-events: none;
        }

        .controls-guide {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .pill {
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: bold;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
        }

        #lock-status {
            display: inline-block;
            margin-top: 15px;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        canvas.output_canvas {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 280px;
            height: 210px;
            z-index: 6;
            transform: rotateY(180deg);
        }

        .loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00d4ff;
            font-size: 1.2rem;
        }
    </style>
</head>
<body>

<div id="container">
    <div id="overlay">
        <h1 style="margin:0; font-size: 1.8rem; color: #00d4ff;">Dual-Hand Galaxy Command</h1>
        <div class="controls-guide">
            <div class="pill">RIGHT: Move & Pinch</div>
            <div class="pill">LEFT: Fist to Lock</div>
        </div>
        <div id="lock-status" style="background: rgba(0,255,100,0.2); border: 1px solid #00ff64; color: #00ff64;">SYSTEM ACTIVE</div>
    </div>
    <video id="input-video" playsinline></video>
    <canvas class="output_canvas"></canvas>
    <div id="loader" class="loader">CONNECTING TO WEBCAM...</div>
</div>

<script>
/**
 * --- THREE.JS STARFIELD ---
 */
let scene, camera, renderer, stars;
let targetRotationX = 0.5, targetRotationY = 0;
let targetZoom = 50;
let isLocked = false;

function initThree() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('container').appendChild(renderer.domElement);

    const geo = new THREE.BufferGeometry();
    const count = 25000;
    const pos = new Float32Array(count * 3);
    const cols = new Float32Array(count * 3);

    for (let i = 0; i < count * 3; i += 3) {
        const r = Math.random() * 50;
        const theta = r * 0.6 + Math.random() * 0.5;
        const phi = Math.random() * Math.PI * 2;
        
        pos[i] = Math.cos(phi + theta) * r + (Math.random()-0.5)*3;
        pos[i+1] = (Math.random()-0.5) * (1 + r * 0.08);
        pos[i+2] = Math.sin(phi + theta) * r + (Math.random()-0.5)*3;

        const p = Math.random();
        if(p > 0.8) { cols[i]=0.2; cols[i+1]=0.6; cols[i+2]=1; } // Blue
        else if(p > 0.4) { cols[i]=0.8; cols[i+1]=0.2; cols[i+2]=0.9; } // Purple
        else { cols[i]=1; cols[i+1]=1; cols[i+2]=1; } // White
    }

    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
    stars = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.08, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending }));
    scene.add(stars);

    animate();
}

function animate() {
    requestAnimationFrame(animate);
    stars.rotation.y += (targetRotationY - stars.rotation.y) * 0.05;
    stars.rotation.x += (targetRotationX - stars.rotation.x) * 0.05;
    camera.position.z += (targetZoom - camera.position.z) * 0.05;
    if(!isLocked) stars.rotation.y += 0.0005;
    renderer.render(scene, camera);
}

/**
 * --- DUAL HAND LOGIC ---
 */
const videoElement = document.getElementById('input-video');
const canvasElement = document.getElementsByClassName('output_canvas')[0];
const canvasCtx = canvasElement.getContext('2d');
const loader = document.getElementById('loader');
const lockStatus = document.getElementById('lock-status');

function onResults(results) {
    loader.style.display = 'none';
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

    let leftHandFist = false;

    if (results.multiHandLandmarks && results.multiHandedness) {
        for (let i = 0; i < results.multiHandLandmarks.length; i++) {
            const landmarks = results.multiHandLandmarks[i];
            const label = results.multiHandedness[i].label; // "Left" or "Right"
            
            // NOTE: MediaPipe labels are mirrored. "Left" in code usually means user's physical right.
            // We'll adjust based on that.
            
            const isFist = landmarks[12].y > landmarks[10].y && 
                           landmarks[16].y > landmarks[14].y && 
                           landmarks[20].y > landmarks[18].y;

            // DRAWING PREVIEW
            let drawColor = (label === "Left") ? "#FFCC00" : "#00D4FF"; // Gold for left, Cyan for right
            if (label === "Left" && isFist) drawColor = "#FF0000";

            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: drawColor, lineWidth: 3});
            drawLandmarks(canvasCtx, landmarks, {color: '#FFFFFF', radius: 1});

            // LOGIC
            if (label === "Left") {
                // If the "Left" hand is a fist, we lock the system
                if (isFist) leftHandFist = true;
            } else if (label === "Right") {
                // Only update Right Hand values if Left Hand is NOT a fist
                if (!leftHandFist) {
                    // ROTATE
                    targetRotationY = (landmarks[8].x - 0.5) * 6;
                    targetRotationX = (landmarks[8].y - 0.5) * 6;

                    // ZOOM
                    const dist = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
                    targetZoom = Math.max(10, Math.min(95, 110 - (dist * 450)));
                }
            }
        }
    }

    // UPDATE UI
    if (leftHandFist) {
        isLocked = true;
        lockStatus.innerText = "LOCKED (LEFT FIST)";
        lockStatus.style.background = "rgba(255,0,0,0.3)";
        lockStatus.style.borderColor = "red";
        lockStatus.style.color = "red";
    } else {
        isLocked = false;
        lockStatus.innerText = "SYSTEM ACTIVE";
        lockStatus.style.background = "rgba(0,255,100,0.2)";
        lockStatus.style.borderColor = "#00ff64";
        lockStatus.style.color = "#00ff64";
    }
    
    canvasCtx.restore();
}

const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
    maxNumHands: 2, // Enable two hands
    modelComplexity: 1,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6
});
hands.onResults(onResults);

const cameraMP = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 640, height: 480
});

initThree();
cameraMP.start();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>